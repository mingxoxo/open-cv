#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp> 
#include <opencv2/nonfree/features2d.hpp> 
#include <opencv2/flann/flann.hpp>

using namespace cv;
#define RED Scalar(0,0,255)

int main()
{
	Mat img1 = imread("C:/opencv-2-4-13-6/image/model3.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	Mat img2 = imread("C:/opencv-2-4-13-6/image/scene.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	assert(img1.data && img2.data);

	SiftFeatureDetector detector(0.3);
	std::vector<KeyPoint> keypoint1, keypoint2;

	detector.detect(img1, keypoint1);
	detector.detect(img2, keypoint2);
	
	Mat disp;
	drawKeypoints(img1, keypoint1, disp, RED, DrawMatchesFlags::DRAW_RICH_KEYPOINTS);
	namedWindow("키포인트"); imshow("키포인트", disp);
	
	SiftDescriptorExtractor extractor;
	Mat descriptor1, descriptor2;
	extractor.compute(img1, keypoint1, descriptor1);
	extractor.compute(img2, keypoint2, descriptor2);
	FlannBasedMatcher matcher;
	std::vector<DMatch> match;
	matcher.match(descriptor1, descriptor2, match);

	double maxd = 0; double mind = 100;
	for (int i = 0; i < descriptor1.rows; i++) {
		double dist = match[i].distance;
		if (dist < mind) mind = dist;
		if (dist > maxd) maxd = dist;
	}

	std::vector<DMatch> good_match;
	for (int i = 0; i < descriptor1.rows; i++)
		if (match[i].distance <= max(2 * mind, 0.02)) good_match.push_back(match[i]);

	Mat img_match;
	drawMatches(img1, keypoint1, img2, keypoint2, good_match, img_match, Scalar::all(-1), Scalar::all(-1),
		vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

	namedWindow("매칭 결과"); imshow("매칭 결과", img_match);

	for (int i = 0; i < (int)good_match.size(); i++)
		printf("키포인트 %d~%d\n", good_match[i].queryIdx, good_match[i].trainIdx);
		
	waitKey();
	return 0;
}
